<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[idea常用快捷键]]></title>
    <url>%2F2018%2F06%2F11%2Fidea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse 使用习惯了再加上 IDEA 可以设置 eclipse 快捷键导致一直不愿意学习 IDEA 下面的快捷键，但是有些时候用同事电脑的时候总是不方便，所以还是记忆一下吧 编辑类Ctrl+N 新建文件 Ctrl+A 全选 双击括号右边（小括号，中括号，花括号）将选择括号内的所有内容 Ctrl+X 剪切 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+Z 撤销 Ctrl+Y 后悔撤销 Ctrl+D 删除当前行 Ctrl+S 保存 Ctrl+Shift+S 保存所有未保存的文件。 Alt+↑ 当前行向上移动 Alt+↓ 当前行向下移动 Ctrl+Alt+↑或↓ 快速复写当前行 Shift+Enter 在当前行的下面添加一个空行，使用时光标可以当前行的任意位置 Shift+Ctrl+Enter 在当前行的上面添加一个空行，使用时光标可以当前行的任意位置 Ctrl+Shift+X 把当前选中的文本全部变为大写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Alt+Shift+A 多行同时输入（吊炸天的功能，泡妞必备） 光标跳转Alt + → 跳到前一次编辑的地方 Alt + ← 跳到后一次编辑的地方 Ctrl+Q 跳到最后一次编辑的地方 Ctrl+L 跳转到某行（使用前最好先打开编辑器显示行号的功能【Ctrl+F10 再点击N】） Ctrl+Home 跳转到文档最前面 Ctrl+End 跳转到文档最后面 Ctrl+鼠标点击 跳到声明或定义的地方。 Ctrl+Shift+P 光标跳到匹配的括号 下面这几个一般用于搜索而且都支持通配符Ctrl+Shift+K 搜索上一个匹配的变量 Ctrl+K 搜索下一个匹配的变量 Ctrl+H 综合搜索 Ctrl+shift+T 搜索类 Ctrl+Shift+H 在层次结构中打开某个类 Ctrl+F 当前类中搜索字符 Ctrl+Shift+R 查找当前项目中的文件(比如gif文件xml文件，支持通配符) Ctrl+O 当前类的所有方法 Ctrl+T 当前类的继承结构 F4 打开类型层次结构（当前类的所有方法，以及继承结构） Ctrl+Alt+H 查看都有谁调用过当前方法(或者在方法名字上右键选择Reference再选择Project) Ctrl+E 已经在编辑窗口打开的文件列表 Ctrl+Shift+G 在workspace中搜索引用（搜狗输入法默认会占用这个键） 自动化Alt+/ 代码助手，提示代码（如果你记不住关键字一定要记住这个快捷键） Ctrl+Shift+O 自动引入所需要得包,多余的包会被删除。 Ctrl+Shift+F 自动格式化代码 Ctrl+/ 注释当前行,再按则取消注释 Ctrl+Shift+/ 注释选定的代码 Ctrl+Shift+\ 取消选定的已经注释的代码 Ctrl+/(小键盘) 折叠/展开当前类中的所有代码 Ctrl+1 快速纠正错误 修改属性Alt+Enter 显示当前选择项目或者文件的属性（我一般用来修改当前项目或文件的字符编码，或者web项目的项目名） 控制视图和编辑器Shift+Alt+b 打开源码视图上方的导航条 Ctrl+W 关闭当前Editer Ctrl+M 最大化当前的edit或View，再按则反之 Alt+- 系统菜单(最小化最大化.关闭其他,关闭当前,关闭全部) Ctrl+Shift+F4 关闭所有打开的Editer F12 全局激活编辑器 Ctrl+↑ 文本编辑器 上滚行 Ctrl+↓ 文本编辑器 下滚行 Ctrl+W 关闭当前编辑的类 Ctrl+Shift+W 关闭所有打开的类 Ctrl+Shift+F6 全局 上一个编辑器 Ctrl+F6 全局 下一个编辑器 Ctrl+F7 全局 下一个视图 Ctrl+Shift+F7 全局 上一个视图 Ctrl+F8 全局 下一个透视图 Ctrl+Shift+F8 全局 上一个透视图 重构Shift+Alt+S Source Shift+Alt+M 抽取方法 Shift+Alt+V 移动函数和变量 Shift+Alt+Z 撤销重构 F2 修改文件名项目名 Shift+Alt+R 重名命（如果你的变量被多处调用，那么修改时使用这个可以一次搞定） Shift+Alt+C 修改函数结构(有N个函数调用了这个方法,修改一次搞定) Shift+Alt+L 抽取本地变量 Shift+Alt+I 合并变量 调试F5单步调试进入函数内部。 F6单步调试不进入函数内部。 F7由函数内部返回到调用处。 F8一直执行到下一个断点。 打开文件 shift+alt+w 可以选择打开的方式，比如在资源管理器里面打开 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2018/06/11/idea常用快捷键/]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin简明教程]]></title>
    <url>%2F2017%2F11%2F16%2FKotlin%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Kotlin简明教程 变量、枚举1234567//var 声明变量，可以指定类型，也可以交给 kotlin 自行推断类型var name="tom"var name:String="jerry"//val 声明常量，可以指定类型，也可以交给 kotlin 自行推断类型val age=18val age:Int=16 常量接口、类、函数函数123456789//传入两个 Int 类型参数，返回 Int 类型结果fun sum(a: Int, b: Int): Int &#123; return a + b&#125;//传入两个 Int 类型参数，没有返回值。没有返回时可以省略 :Unitfun printSum(a: Int, b: Int): Unit &#123; println("sum of $a and $b is $&#123;a + b&#125;")&#125; 逻辑判断集合操作集合初始化遍历集合12345678910111213141516 // HashSet val hashSet = hashSetOf(1, 0, 0, 8, 6) println("hashSet = $hashSet") println("hashSet 最后一个元素 = $&#123;hashSet.last()&#125;") println("hashSet 中的最大值 = $&#123;hashSet.max()&#125;")// setOf&lt;&gt;()// listOf&lt;&gt;() // HashMap val hashMap = hashMapOf("a" to "tom", "b" to "jerry", "c" to "bill") println("hashMap = $hashMap") // ArrayList val arrayList = arrayListOf("a", "b", "c", "d") println("arrayList = $arrayList") 泛型反射线程其他 每行代码的结尾可以没有分号 包的定义和 Java 一样 12345package my.demoimport java.util.*// …… println输出支持占位符，免去了Java中的加号拼接 12345var name = &quot;tom&quot;var age = 18//我是tom,今年28岁了println(&quot;我是$&#123;name&#125;,今年$&#123;age+10&#125;岁了&quot;) null 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/11/16/Kotlin简明教程/]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的NIO]]></title>
    <url>%2F2017%2F11%2F16%2FJava%E7%9A%84NIO%2F</url>
    <content type="text"><![CDATA[对 Java NIO 的理解 用 Java 实现一个简单的服务器 12 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/11/16/Java的NIO/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的时间操作]]></title>
    <url>%2F2017%2F11%2F07%2Fjava%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Java 中常用的时间操作案例 JDK8之前建议引入第三方库joda-time 12345&lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt; 时间差123456789101112131415DateTime startTime = DateTime.parse(&quot;2016-06-07 10:10:38&quot;, DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))DateTime finishTime = DateTime.parse(&quot;2016-06-07 10:50:37&quot;, DateTimeFormat.forPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))println &quot;----------------------时间差------------------------&quot;int days = Days.daysBetween(startTime, finishTime).getDays()int hours=Hours.hoursBetween(startTime, finishTime).getHours()int minutes=Minutes.minutesBetween(startTime, finishTime).getMinutes()int seconds=Seconds.secondsBetween(startTime, finishTime).getSeconds()println &quot;$&#123;days&#125;天&quot;println &quot;$&#123;hours&#125;小时&quot;println &quot;$&#123;minutes&#125;分钟&quot;println &quot;$&#123;seconds&#125;秒&quot;println &quot;--------------------合并时间差------------------------&quot;println &quot;$&#123;days&#125;天$&#123;hours % 24&#125;小时$&#123;minutes % 60&#125;分钟$&#123;seconds % 60&#125;秒&quot; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/11/07/java中的时间操作/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>时间操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java文件操作案例]]></title>
    <url>%2F2017%2F11%2F06%2FJava%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[总结常见的文件操作、流操作的用法 文件操作常见流123InputStream ： 是所有字节输入流的超类，一般使用它的子类：FileInputStream等，它能输出字节流；InputStreamReader ： 是字节流与字符流之间的桥梁，能将字节流输出为字符流，并且能为字节流指定字符集，可输出一个个的字符；BufferedReader ： 提供通用的缓冲方式文本读取，readLine读取一个文本行， 从字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取。 流操作12345InputStream inputStream = new FileInputStream(new File(&apos;/Users/xxx/test.txt&apos;))//groovy 自动调用 close 关闭流inputStream.withStream &#123; it-&gt; //对输入流操作&#125; 转换String &gt; InputStream1InputStream is = new ByteArrayInputStream(string.getBytes(&quot;UTF-8&quot;)); InputStream &gt; StringString &gt; OutputStreamOutputStream &gt; StringOutputStream &gt; InputStream12ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()ByteArrayInputStream byteArrayInputStream =new ByteArrayInputStream(byteArrayOutputStream.toByteArray()) 123456789101112131415161718192021/** * 将输入流持久化到文件 * * @param file 目标文件 * @param inputStream 要持久化的输入流 * @param append true从头部开始覆盖目标文件内容,false 不覆盖在目标文件尾部追加 * @param bufferSize 使用的内存缓存区大小，推荐传入 8 * 1024 * @throws IOException */ public static void inputStreamToFile(File file, InputStream inputStream, boolean append, int bufferSize) throws IOException &#123; FileOutputStream fileOutputStream = new FileOutputStream(file, append); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream); byte[] data = new byte[bufferSize]; while (inputStream.read(data) != -1) &#123; bufferedOutputStream.write(data); bufferedOutputStream.flush(); &#125; bufferedOutputStream.close(); fileOutputStream.close(); inputStream.close(); &#125; 流的复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import org.apache.commons.io.input.TeeInputStream;import java.io.*;import java.util.concurrent.CompletableFuture;import java.util.function.Consumer;/** * 流的复制，将一个InputStream变成多个InputStream * &lt;p&gt; * &lt;code&gt; Shunt .load(fileInputStream) .pipo(new Consumer() &#123; @Override public void accept(Object o) &#123; InputStream inputStream = (InputStream) o; try &#123; IOUtil.inputStreamToFile(new File(&quot;d:/bz/1.csv&quot;), inputStream, true, 8 * 1024); inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, new Consumer() &#123; @Override public void accept(Object o) &#123; InputStream inputStream = (InputStream) o; try &#123; IOUtil.inputStreamToFile(new File(&quot;d:/bz/2.csv&quot;), inputStream, true, 8 * 1024); inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; ); * &lt;/code&gt; * &lt;p&gt; * Created by liutf on 2016/7/6 0006. */public class Shunt &#123; InputStream inputStream; public static Shunt load(InputStream inputStream) &#123; return new Shunt(inputStream); &#125; private Shunt(InputStream inputStream) &#123; this.inputStream = inputStream; &#125; private InputStream shunt(InputStream inputStream) throws IOException &#123; PipedInputStream in = new PipedInputStream(); PipedOutputStream out = new PipedOutputStream(in); TeeInputStream tee = new TeeInputStream(inputStream, out, true); this.inputStream = in; return tee; &#125; public Shunt pipo(Consumer&lt;InputStream&gt;... consumers) throws IOException &#123; for (Consumer&lt;InputStream&gt; consumer : consumers) &#123; InputStream br = shunt(inputStream); CompletableFuture.runAsync(() -&gt; &#123; try &#123; consumer.accept(br); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); &#125; return this; &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/11/06/Java文件操作案例/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>groovy</tag>
        <tag>Java</tag>
        <tag>文件操作</tag>
        <tag>流操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当设计模式遇到Spring]]></title>
    <url>%2F2017%2F07%2F08%2F%E5%BD%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%81%87%E5%88%B0Spring%2F</url>
    <content type="text"><![CDATA[当你使用 Spring 的时候是否感觉他帮助了又限制了你？ 抽象类里面如何注入1234567891011121314151617181920//子类受到Spring管理，子类继承抽象类@Componentclass DemoFacade extends AbstractDemoFacade &#123; @Autowired Prop prop public Prop getProp() &#123; return apiDocSetting &#125;&#125;//抽象类abstract class AbstractDemoFacade &#123; //加上一个抽象的getter方法让子类去实现即可获取子类注入的属性 abstract Prop getProp() protected String mehtod1()&#123; getProp().xxx //读取子类注入属性中的值 &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/07/08/当设计模式遇到Spring/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中枚举的各种用法]]></title>
    <url>%2F2017%2F06%2F26%2FJava%E4%B8%AD%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%90%84%E7%A7%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用法实例化多个构造函数反射搜索应用场景单例模式 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/06/26/Java中枚举的各种用法/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射总结]]></title>
    <url>%2F2017%2F06%2F26%2FJava%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结Java反射中的常见用法 类型判断clazz.typeName == &quot;void&quot; // Void clazz.typeName == &quot;java.lang.Boolean&quot; // 布尔类型 clazz.isEnum() // 枚举类型 clazz.isArray() // 数组 反射实例化枚举类型每个枚举的值都是一个单例，这里其实并不是实例化而是把已经存在的单例匹配出来 //假设我们定义了一个枚举 enum UserSexEnum { WOMAN, MAN } //反射获取 UserSexEnum 里面所有的实例 Enum[] enums=UserSexEnum.class.getEnumConstants() enums.any {it.name()==&quot;WOMAN&quot;} //判断是否存在一个实例是 WOMAN 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/06/26/Java反射总结/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>groovy</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java后端JSON解析全解]]></title>
    <url>%2F2017%2F06%2F26%2FJava%E5%90%8E%E7%AB%AFJSON%E8%A7%A3%E6%9E%90%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[fastJson jackson Gson NutzJson 本文只关注用法，不关注各个框架的性能对比,更多资料请参考各自官网 对象转JSON字符串JSON字符串转对象JSON格式化输出 jackson ObjectMapper mapper = new ObjectMapper(); System.out.println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(user)); fastJson NutzJson JSON对泛型的处理众多Json框架都会遇到的问题 JSON注释标准json是不支持注释的，但是当我们有这个需求的时候怎么办？ 给JSON加注释 nutzJson 带有注释JSON 引子 随着 JSON 应用场景的增加，为了满足需求很多不规范的 JSON 也出现了 对于后端开发来说常用的注释有以下三种 # 单行注释 // 单行注释 /* */ 多行注释 实际的开发中经常会有队友为了便于理解,习惯性的就用这三种形式给 JSON 加上注释 带有这些注释的 JSON 不是标准的 JSON。 虽然不规范，但是容易理解，尤其是在接口文档中这种形式还是很受欢迎的 于是如何解析这种带有注释 JSON 就成了一个问题 方法一：使用正则替换 String result =JsonStr.replaceAll(&quot;//.*[\\n|\\r\\n]&quot;, &quot;&quot;) .replaceAll(&quot;/\\*[\\s\\S]*\\*/&quot;, &quot;&quot;) .replaceAll(&quot;#.*[\\n|\\r\\n]&quot;, &quot;&quot;) 如何自己写个JSON解析器前端支持带有注释的 Json 框架 http://json5.org/ https://www.npmjs.com/package/jsonminify 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/06/26/Java后端JSON解析全解/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>J2EE</tag>
        <tag>javaWeb</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[groovy和Java混合编程之集合的使用]]></title>
    <url>%2F2017%2F06%2F26%2Fgroovy%E5%92%8CJava%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[groovy 简化了 Java 语法，并且增加了一些集合的常用操作Java8 中也提供了 stream 以满足复杂的集合操作需求日常集合操作代码案例这里都有 创建创建数组1String[] contents = &#123; &quot;tom&quot;, &quot;jerry&quot;, &quot;bill&quot;&#125;; 创建list java 语法 12345List&lt;User&gt; list = new ArrayList&lt;User&gt;()&#123;&#123; add(new User(&quot;tom&quot;,18)); add(new User(&quot;bill&quot;,14)); add(new User(&quot;jerry&quot;,16));&#125;&#125;; groovy 语法 集合与数组的转换创建map### java 语法 groovy 语法 def map=[:] //空的map def map=[&quot;a&quot;:1 ,&quot;b&quot;:2] 遍历Java 遍历 listgroovy 遍历 listJava 遍历 map 方法一 def map = [&quot;a&quot;: 1, &quot;b&quot;: 2] for (Map.Entry&lt;String,Integer&gt; entry : map) { println entry.key+&quot;---&quot;+entry.value } 方法二 只对 key 遍历 for (String key : map.keySet()) { System.out.println(key + &quot; = &quot; + map.get(key)); } 只对 value 遍历 for (String value : map.values()) { System.out.println(&quot;value = &quot; + value); } 方法三 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) { Map.Entry&lt;String, Integer&gt; entry = entries.next(); System.out.println(entry.key + &quot; = &quot; + entry.value); } 方法四 考虑实际场景如果你的value类型比较复杂你最好带着泛型 map.forEach((String k,Integer v)-&gt;{ System.out.println(k+&quot; = &quot;+v); }); 如果比较简单当然你可以把泛型去掉 map.forEach((k,v)-&gt;{ System.out.println(k+&quot; = &quot;+v); }); 如果仅仅是输出你还可以更简单 map.forEach((k,v)-&gt; System.out.println(k+&quot; = &quot;+v)); groovy 遍历 map 方法一 map.each { k, v -&gt; println k + &quot;---&quot; + v } 方法二：可以获取下标 map.eachWithIndex { Map.Entry&lt;String, Integer&gt; entry, int i -&gt; println entry.key + &quot; = &quot; + entry.value+ &quot;---&quot;+i } 筛选去重 排序集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778List&lt;User&gt; list = [ new User(name: &quot;tom&quot;, age: 18), new User(name: &quot;bill&quot;, age: 18), new User(name: &quot;jerry&quot;, age: 16), new User(name: &quot;judy&quot;, age: 36) ]//Java对集合的排序Collections.sort(list,new Comparator&lt;User&gt;() &#123; //原则： // x 中所有大于 y 的都返回正数，正序排列 // x 中所有小于 y 的都返回负数，倒序排列 // x 中所有等于 y 的都返回0，不排序 @Override int compare(User x, User y) &#123; //正序排列 return x.age.compareTo(y.age) return x.age-y.age //降序 return y.age.compareTo(x.age) return y.age-x.age &#125; &#125;) prinln &quot;集合排序：&quot;+list //Java 对数组排序User[] userArray =[ new User(name: &quot;tom&quot;, age: 18), new User(name: &quot;bill&quot;, age: 18), new User(name: &quot;jerry&quot;, age: 16), new User(name: &quot;judy&quot;, age: 36) ]Arrays.sort(userArray, new Comparator&lt;User&gt;() &#123; @Override int compare(User o1, User o2) &#123; //正序 return o1.age.compareTo(o2.age) //倒序 return o2.age.compareTo(o1.age) &#125;&#125;)println &quot;数组排序：&quot;+userArray//Java8中可以使用 lambda 表达式来写//升序list.sort((o1, o2) -&gt; o1.getAge().compareTo(o2.getAge())); //方法1list.sort(Comparator.comparing(User::getAge));//方法2Collections.sort(list, Comparator.comparing(User::getAge));//方法3//倒序list.sort((o1, o2) -&gt; o2.getAge().compareTo(o1.getAge()));//方法1list.sort(Comparator.comparing(User::getAge).reversed());//方法2Collections.sort(list, Comparator.comparing(User::getAge).reversed());//方法3 //groovy 的闭包对集合和数组的排序可以如下简写list.sort &#123; x, y -&gt; //正序 return x.age.compareTo(y.age) return x.age-y.age return x.age &lt;=&gt; y.age //倒序 return y.age.compareTo(x.age) return y.age-x.age return y.age &lt;=&gt; x.age&#125;prinln &quot;排序后：&quot;+list//groovy 打乱一个集合或者数组Integer[] arr = [2, 4, 6, 1, 0]def arr2 = arr.sort&#123; Math.random()&#125;println arr2 分组合并多个 list 合并成一个List&lt;List&lt;Integer&gt;&gt; list = [[1], [11,12], [21,22,23], [31,32,33], [41,42,43,44]] List&lt;Integer&gt; result = list.stream() .flatMap({ it.stream().map({it}) }) .collect(Collectors.toList()); 或者 List&lt;Integer&gt; result = list.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); println list 输出结果：[1, 11, 12, 21, 22, 23, 31, 32, 33, 41, 42, 43, 44] – 复杂的场景：多个异步执行结果的返回值合并到一起 CompletableFuture future1=CompletableFuture.supplyAsync({ TimeUnit.SECONDS.sleep(1) //延迟一秒返回 return [1,2,3] }); CompletableFuture future2=CompletableFuture.supplyAsync({ TimeUnit.SECONDS.sleep(5) //延迟五秒返回 return [4,5,6,7,8,9] }); List&lt;Integer&gt; collect= Stream.of(future1,future2) .flatMap({(it.join() as List&lt;Integer&gt;).stream().map({it}) }) .collect(Collectors.toList()); println collect 五秒钟后输出结果：[1, 2, 3, 4, 5, 6, 7, 8, 9] 多个map的结果合并到一起转换list 转 map一个list：提取一个属性作为key，其他的值作为value1234567891011121314151617181920212223class Person &#123; Integer salary String emailId&#125;Person person1=new Person(salary:25000,emailId:&quot;anamika@gmail.com&quot;)Person person2=new Person(salary:23000,emailId:&quot;sanjana@gmail.com&quot;)Person person3=new Person(salary:26000,emailId:&quot;khalid@gmail.com&quot;)Person person4=new Person(salary:20000,emailId:&quot;anjali@gmail.com&quot;)Person person5=new Person(salary:22000,emailId:&quot;aditya@gmail.com&quot;)List&lt;Person&gt; persons=[person1,person2,person3,person4,person5]//方法一Map&lt;String,Integer&gt; result = persons.collectEntries&#123;[it.emailId,it.salary]&#125;//方法二Map&lt;String,Integer&gt; result = persons.collectEntries&#123;[(it.emailId):it.salary]&#125;//输出结果Output of result -&gt; [anamika@gmail.com:25000, sanjana@gmail.com:23000, khalid@gmail.com:26000, anjali@gmail.com:20000, aditya@gmail.com:22000] java8 123456789101112131415161718 List&lt;PhotoExcel&gt; list = [ new PhotoExcel(bucket: &quot;a&quot;, dir: &quot;a/a&quot;), new PhotoExcel(bucket: &quot;a&quot;, dir: &quot;a/b&quot;), new PhotoExcel(bucket: &quot;b&quot;, dir: &quot;b/b&quot;), new PhotoExcel(bucket: &quot;b&quot;, dir: &quot;b/b&quot;), ] def map = list.stream().collect( Collectors.groupingBy(new Function&lt;PhotoExcel, String&gt;() &#123; @Override String apply(PhotoExcel photoExcel) &#123; return photoExcel.bucket &#125; &#125;, Collectors.mapping(Function.identity(), Collectors.toList()))) println JSON.toJSONString(map) //输出：&#123;&quot;a&quot;:[&#123;&quot;bucket&quot;:&quot;a&quot;,&quot;dir&quot;:&quot;a/a&quot;&#125;,&#123;&quot;bucket&quot;:&quot;a&quot;,&quot;dir&quot;:&quot;a/b&quot;&#125;],&quot;b&quot;:[&#123;&quot;bucket&quot;:&quot;b&quot;,&quot;dir&quot;:&quot;b/b&quot;&#125;,&#123;&quot;bucket&quot;:&quot;b&quot;,&quot;dir&quot;:&quot;b/b&quot;&#125;]&#125; 两个长度相同的list：一个list作为key，另外一个list对应的下标值作为valuesetUp: String[] arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] Integer[] arr2 = [4, 5, 6] 想要的结果：[a:4, b:5, c:6] 方法1：最常规的做法在遍历一个集合的同时通过下标获取另一个 Map&lt;String,Integer&gt; result=[:] arr1.eachWithIndex { String entry, int i -&gt; result.put(entry,arr2[i]) } 方法2： 先转换为二维数组再把二维数组转换为map，感觉比较玩的花哨 def result = [arr1, arr2].transpose() //先转换为：[[&quot;a&quot;,4],[&quot;b&quot;,5],[&quot;c&quot;,6]] .inject([:]) { entry, it -&gt;entry + [(it[0]):(it[1])]} 方法3：和方法2思想一样，只是混合 Java8 的语法 def result = [arr1, arr2].transpose() .stream().collect(Collectors.toMap({it[0]},{it[1]})) map 转 list转换内容格式def a=[1,2,3].stream().map({it+&quot;转成字符串格式&quot;}).collect(Collectors.toList()) def b=[1,2,3].collect({ it+&quot;转成字符串格式&quot; }) println a println b 合并map合并12345678Map a=[&quot;a&quot;:1]Map b=[&quot;b&quot;:2]Map c=[&quot;a&quot;:3] //相同的 key 后面的会把前面的覆盖a.putAll(b)a.putAll(c)println a 分页java8 123456789101112int pageSize=20; //每页多少条List&lt;GoodsDTO&gt; goodsList =new ArrayList&lt;&gt;(); //要分页的数据 int page = (goodsList.size() + (pageSize - 1)) / pageSize; //分页 List&lt;List&lt;GoodsDTO&gt;&gt; goodsListPage = Stream.iterate(0, n -&gt; n + 1) .limit(page) .parallel() .map(currPage -&gt; goodsList.stream() .skip(currPage * pageSize) .limit(pageSize) .collect(Collectors.toList()) ).collect(Collectors.toList()); guava 123int pageSize=20; //每页多少条List&lt;GoodsDTO&gt; goodsList =new ArrayList&lt;&gt;(); //要分页的数据 List&lt;List&lt;GoodsDTO&gt;&gt; lists = Lists.partition(goodsList, pageSize); 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2017/06/26/groovy和Java混合编程之集合的使用/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>groovy</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git提交代码时配置多个远程库地址]]></title>
    <url>%2F2016%2F12%2F08%2Fgit%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[如果你们公司的gitlab上有一个项目想要开源到github上，如果你想提交代码的时候同时提交到github、gitlab、coding、osc 等多个仓库里，那么你就需要在你的项目里面配置多个远程仓库地址。 首先你要登录到这些网站上面，在上面创建仓库，这里就省略不讲了。我们先来看一下最初的远程配置长什么样子： 当然你也可以通过 git remote -v 命令查看你的远程库地址可以发现fetch和push都是同一个地址，下面我们就给push的时候添加多个地址 一个远程库中配置多个url这个是我们要新添加的github的提交地址 git remote set-url –add –push origin git@github.com:nofdev/service-topic-consumer.git这个是我们原先的gitlab的提交地址 git remote set-url –add –push origin git@gitlab.yintai.org:architect/service-topic-consumer.git 你可以按照上面的格式添加更多的提交地址。 我们看看生成的配置的文件是什么样子： 运行 git remote -v 再次看看 配置多个远程库分别提交我们也可以指定多个分组，每个分组对应一个网站仓库，提交的时候可以单独提交到某个网站仓库 添加一个github分组 git remote add github git@github.com:nofdev/service-topic-consumer.git再添加一个gitlab分组 git remote add gitlab git@gitlab.yintai.org:architect/service-topic-consumer.git 我们看看生成的配置的文件是什么样子 那么到此为止我们就全部配置完成了：当我想推送到 github 时，执行 git push github当我想推送到 gitlab 时，执行 git push gitlab当我想全部推送，执行 git push PS: 如果你想删除origin分组，可以使用 git remote rm origin 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/12/08/git提交代码时配置多个远程库地址/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Code常用快捷键]]></title>
    <url>%2F2016%2F12%2F02%2FVisual-Studio-Code%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Visual Studio Code常用快捷键官方文档：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 快速将当前文件夹在 vscode 中打开当前文件夹下按住shift键再点击鼠标右键，可以看到“在此处打开命令窗口(W)”,点击此选项然后输入 code . 即可打开 控制视图窗口 ctrl+shift+n 新建窗口 Ctrl+Shift+w 关闭窗口 Ctrl+N 新建文件 ctrl+b 切换侧边栏 ctrl+\ 拆分编辑器 搜索 Ctrl+P 本地文件搜索，默认列出了你打开过的文件 Ctrl+F 当前打开的文件内搜索代码 Ctrl+H 当前打开的文件内搜索和替换 Ctrl+Shift+F 在整个项目中搜索代码出现的位置 F12 跳转到代码定义处 Alt+F12 显示代码定义处的缩略图但是不跳转过去 shift+F12 列出所有的引用 编辑 Alt+左右箭头 回到前后几次编辑的地方 Alt+上下箭头 上下移动选中的代码 Alt+Shift+上下箭头 上下复制当前选中行 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/12/02/Visual-Studio-Code常用快捷键/]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows使用shadowsocks和Proxifier实现为电脑上任何一个程序代理]]></title>
    <url>%2F2016%2F08%2F29%2FWindows%E4%BD%BF%E7%94%A8shadowsocks%E5%92%8CProxifier%E5%AE%9E%E7%8E%B0%E4%B8%BA%E7%94%B5%E8%84%91%E4%B8%8A%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[shadowsocks、Proxifier，window下翻墙黄金搭档 查看我们的shadowsocks的端口 配置proxifier 检查是否可用 给我们的代理起个名字 然后一路点“确定“ ，遇到下面这个图，直接点”是“即可 测试一下 可以发现当我们使用其他的软件访问网络的时候都被代理了到目前为止我们的代理是对全局起作用的，电脑上任何一个应用程序要联网都会经过这个代理，下面我们来看如何为指定的某个程序代理 设置代理规则菜单：配置文件——&gt;代理规则我们来看一下最终的配置以及所代表的含义 另外一种临时生效代理规则通过对想代理的软件点击右键选择想使用的代理即可 你有可能遇到的问题在第7步的时候，你通过代理规则里面的浏览按钮选择想要代理的软件可能不一定会生效，这时你可以通过“任务管理器”找到该应用程序的进程名字，然后手动添加到代理规则的应用程序里面，多个应该程序之间使用英文分号分隔，如下图 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/08/29/Windows使用shadowsocks和Proxifier实现为电脑上任何一个程序代理/]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>proxifier</tag>
        <tag>翻墙</tag>
        <tag>GFW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建FireKylin博客系统]]></title>
    <url>%2F2016%2F08%2F11%2F%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAFireKylin%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[简介：FireKylin是一个nodejs的博客系统 运行一个空的Ubuntu容器docker run -it -p 80:8360 --name=web_node_firekylin ubuntu bash 安装nodejs 和 npm 先更新一下软件仓库列表 apt-get update 安装nodejs和npm apt-get install -y nodejs apt-get install -y npm 验证安装是否成功： 查看安装的nodejs版本 nodejs -v 查看安装的npm版本 npm -v 为了兼容以前的老版本建议安装这个 apt-get install nodejs-legacy 下载网站源码文件 创建一个目录作为我们的站点目录 cd home &amp;&amp; mkdir myblog &amp;&amp; cd myblog 安装wget用于下载文件 apt-get install -y wget wget -c http://firekylin.org/release/firekylin_0.12.6.tar.gz 把文件解压 tar -zxvf firekylin_0.12.6.tar.gz 进入解压后的文件夹,安装node依赖 cd /home/myblog/firekylin &amp;&amp; npm install 服务器环境推荐pm2启动 安装vim用于修改配置文件 apt-get install -y vim-gtk 安装pm2 npm install -g pm2 将pm2_default.json配置文件的名称修改为pm2.json mv pm2_default.json pm2.json 修改pm2.json配置，将cwd修改为当前目录 端口映射 因为我们的网站运行在docker容器里面需要端口映射，而firekylin默认不让通过ip:端口号的形式访问， 所以这里需要解除限制，参考：https://thinkjs.org/zh-cn/doc/2.1/force_proxy.html 在配置文件 src/common/config/hook.js，添加如下的配置： export default { request_begin: [&quot;prepend&quot;, &quot;force_proxy&quot;] } 修改配置 src/common/config/config.js 中的host为0.0.0.0 export default { host: &quot;0.0.0.0&quot; } 启动项目pm2 start pm2.json docker容器内部访问 http://127.0.0.1:8360宿主机里面访问 http://127.0.0.1:80 首次打开会进入安装界面，按照提示填写数据库信息和网站管理员信息就行了 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/08/11/使用docker搭建FireKylin博客系统/]]></content>
      <categories>
        <category>博客系统</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nodejs</tag>
        <tag>FireKylin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker安装mysql]]></title>
    <url>%2F2016%2F08%2F08%2F%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[获取mysql镜像docker pull mysql:5.7 运行一个容器docker run -d --name=mysql -p 3399:3306 -e MYSQL_ROOT_PASSWORD=pwd123456 mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 参数解释： -d //后台运行容器 --name=mysql //容器名myql -p 3399:3306 //宿主机的3399端口映射到容器的3306端口 -e MYSQL_ROOT_PASSWORD=pwd123456 //通过环境变量设置数据库密码为pwd123456 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci //防止中文乱码 注意：如果你需要外网访问该数据库，你需要在云服务器后台把宿主机的3399端口开放 查看容器运行日志docker logs mysql 客户端 使用shell docker exec -it mysql bash 使用mysql的工具，比如navicat连接 略 更多配置参考：https://hub.docker.com/_/mysql/ 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/08/08/使用docker安装mysql/]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker安装shadowsocks]]></title>
    <url>%2F2016%2F07%2F28%2F%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85shadowsocks%2F</url>
    <content type="text"><![CDATA[轻功绝技——shadowsocks服务器搭建就是这么简单 第一步：获取docker镜像docker pull shadowsocks/shadowsocks-libev 第二步：启动docker容器-- 查看都有哪些可用参数 docker run --rm shadowsocks/shadowsocks-libev --help -- 运行（这里把密码设置为 tf123456，端口设置为1993，加密方式设置为aes-256-cfb） docker run --name shadowsocks-app --detach --publish 1993:8338 shadowsocks/shadowsocks-libev -m aes-256-cfb -k &quot;tf123456&quot; 第三步：客户端连接 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/07/28/使用docker安装shadowsocks/]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
        <tag>GFW</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc的URL映射和传参案例]]></title>
    <url>%2F2016%2F05%2F31%2FSpringMvc%E7%9A%84URL%E6%98%A0%E5%B0%84%E5%92%8C%E4%BC%A0%E5%8F%82%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Springmvc的基本使用，包括url映射、参数映射、页面跳转、ajax和文件上传 以前学习的时候写的代码案例，今天整理笔记的时候找到了,发上来当个在线笔记用吧，免的时间长了又忘了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271package sy.controller;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Random;import java.util.UUID;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.io.IOUtils;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.multipart.commons.CommonsMultipartFile;import org.springframework.web.servlet.ModelAndView;import power.FuncConstants;import power.Permission;import sy.bean.TestPerson;// 用来标注此类事springMVC管理的控制层的类@Controller// 为了防止多个控制层类有相同的方法所以要为每个控制层类起个唯一的标示名@RequestMapping(value = &quot;/test&quot;)// @Scope(&quot;prototype&quot;) ,如果不加这个注释那么该controller就是单列的，一般我们不在controller当中定义成员变量所以不用加这个注释，struts2中的action中会加这个注释就是因为里面经常会定义成员变量，如果不加这个注释当有多个请求的时候就会照成数据共享错误public class TestController &#123; @RequestMapping(&quot;/hello.do&quot;) // 访问此方法的url路径/test/hello.do public String hello() &#123; return &quot;index&quot;; &#125; // ===========================获取页面中传进来的参数======================================================= /** * 方式一：通过request请求方式接收前台页面传过来的参数 */ @RequestMapping(&quot;/toPerson1.do&quot;) // 访问此方法的url路径为/test/toPerson1.do public String toPerson1(HttpServletRequest request) &#123; String name = request.getParameter(&quot;name&quot;); System.out.println(name); return &quot;index&quot;; &#125; /** * 方式二：通过相匹配的参数列表接收页面参数_String, * 而且在页面参数和参数列表中的参数类型相容的情况下是可以自动类型转换的_Integer * 时间类型如果传入的时间格式比较特殊可以通过自定义专门的转换器来解决（属性编辑器） */ @RequestMapping(&quot;/toPerson2.do&quot;) // 访问此方法的url路径为/test/toPerson2.do public String toPerson2(String name, Integer age, Date birthday) &#123; System.out.println(&quot;姓名：&quot; + name + &quot;,年龄：&quot; + age + &quot;,生日&quot; + birthday); return &quot;index&quot;; &#125; /** * 方式2.1 如果你页面传入的和用于接收的非要不一样那么可以用@RequestParam指定 */ @RequestMapping(&quot;/toPerson21.do&quot;) // 访问此方法的url路径为/test/toPerson21.do public String toPerson21(@RequestParam(&quot;name&quot;) String userName, Integer age, Date birthday) &#123; System.out.println(&quot;姓名：&quot; + userName + &quot;,年龄：&quot; + age + &quot;,生日&quot; + birthday); return &quot;index&quot;; &#125; /** * 注册时间类型的属性编辑器 */ @InitBinder public void initBinder(ServletRequestDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), true)); &#125; /** * 方式三：如果页面传入的参数和接收的实体类（可以为多个实体）中set方法中的参数一致(首字母大小写可以不一致)， * 那么就可以直接给实体类的属性赋值，没有匹配上的将会被赋值为null */ @RequestMapping(&quot;/toPerson3.do&quot;) // 访问此方法的url路径为/test/toPerson3.do public String toPerson3(TestPerson p) &#123; System.out.println(p); return &quot;index&quot;; &#125; /** * 方式三：如过页面传来两个同名的参数值，方法中可以用一个同名参数数组去接收，而且接收到的参数顺序和传入时的相同。 * 如果没有定义成数组传入的参数会以逗号分隔 */ @RequestMapping(&quot;/toPerson4.do&quot;) // 访问此方法的url路径为/test/toPerson4.do public String toPerson4(String[] name) &#123; for (int i = 0; i &lt; name.length; i++) &#123; System.out.println(name[i]); &#125; return &quot;index&quot;; &#125; /** * 方式四：指定form表单的请求方式，如果不指定，那么post和get都可以访问本方法 * desc：@RequestMapping( method=RequestMethod.POST )可以指定请求方式，前台页面就必须要以它制定好的方式来访问，否则出现405错误 */ @RequestMapping(value = &quot;/toPerson5.do&quot;, method = RequestMethod.POST) public String toPerson5(TestPerson person) &#123; System.out.println(person); return &quot;index&quot;; &#125; // ===========================向页面传递参数======================================================= /** * 方式一 desc：方法的返回值采用ModelAndView， new ModelAndView(&quot;index&quot;, map); ，相当于把结果数据放到request里面 */ @RequestMapping(&quot;/toPerson6.do&quot;) public ModelAndView toPerson6() throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;p&quot;, person); return new ModelAndView(&quot;index&quot;, map); &#125; /** * 方式二 desc：直接在方法的参数列表中来定义Map，这个Map即使ModelAndView里面的Map， 由视图解析器统一处理，统一走ModelAndView的接口 */ @RequestMapping(&quot;/toPerson7.do&quot;) public String toPerson7(Map&lt;String, Object&gt; map) throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); map.put(&quot;p&quot;, person); return &quot;index&quot;; &#125; /** * 方式三 desc：在参数列表中直接定义Model，model.addAttribute(&quot;p&quot;, person);把参数值放到request类里面去，建议使用 */ @RequestMapping(&quot;/toPerson8.do&quot;) public String toPerson8(Model model) throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); // 把参数值放到request类里面去 model.addAttribute(&quot;p&quot;, person); return &quot;index&quot;; &#125; // ===========================Ajax的使用======================================================= /** * 方式一 ：ajax的请求返回值类型应该是void，参数列表里直接定义HttpServletResponse， 获得PrintWriter的类，最后可把结果写到页面 */ @RequestMapping(&quot;/ajax.do&quot;) public void ajax(String name, HttpServletResponse response) &#123; String result = &quot;hello &quot; + name; try &#123; response.getWriter().write(result); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 方式二 ：直接在参数的列表上定义PrintWriter，out.write(result);把结果写到页面，建议使用的 */ @RequestMapping(&quot;/ajax1.do&quot;) public void ajax1(String name, PrintWriter out) &#123; String result = &quot;hello &quot; + name; out.write(result); &#125; // ========================跳转 转发和重定向=================================== @RequestMapping(&quot;/redirectToForm.do&quot;) public String redirectToForm() &#123; //同一个类中 desc：controller内部重定向，redirect:加上同一个controller中的requestMapping的值 return &quot;redirect:upload.do&quot;; //不同的类中 desc：controller之间的重定向：必须要指定好controller的命名空间再指定requestMapping的值， redirect：后必须要加/,是从根目录开始// return &quot;redirect:/test/toForm.do&quot;; //同一个类中 desc：controller内部转发，redirect:加上同一个controller中的requestMapping的值// return &quot;forward:toForm.do&quot;; &#125; // ===========================文件上传======================== @RequestMapping(&quot;/upload.do&quot;) // 访问此方法的url路径/test/hello.do public String upload() &#123; return &quot;fileUpload&quot;; &#125; /** * 文件上传方式一 * @param request * @return * @throws Exception */ @RequestMapping(value = &quot;/fileUpload.do&quot;) public String fileUpload(HttpServletRequest request) throws Exception &#123; // 第一步转化request MultipartHttpServletRequest rm = (MultipartHttpServletRequest) request; // 获得原始文件 CommonsMultipartFile cfile = (CommonsMultipartFile) rm.getFile(&quot;pic&quot;); // 获得原始文件名 String origFileName = cfile.getOriginalFilename(); // 获得原始文件的后缀 XXX.jpg String suffix = origFileName.contains(&quot;.&quot;) ? origFileName.substring(origFileName.lastIndexOf(&quot;.&quot;)) : &quot;error&quot;; if (&quot;error&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;error&quot;; &#125; // 获得原始文件的字节数组 byte[] bfile = cfile.getBytes(); // 新文件名=当前时间的毫秒数+3位随机数 String fileName = String.valueOf(System.currentTimeMillis()); // 获得三位随机数 Random random = new Random(); for (int i = 0; i &lt; 3; i++) &#123; fileName = fileName + random.nextInt(9); &#125; // 拿到项目的部署路径 String path = request.getSession().getServletContext().getRealPath(&quot;/&quot;); // 将用户上传的文件保存到服务器上 OutputStream out = new FileOutputStream(new File(path + &quot;/upload/&quot; + fileName + suffix)); IOUtils.write(bfile, out); out.close(); return &quot;success&quot;; &#125; /** * 文件上传方式二 * @param request * @return * @throws Exception */ @RequestMapping(value = &quot;/fileUpload2.do&quot;) public String fileUpload2(@RequestParam(value=&quot;pc&quot;,required=false) MultipartFile file,HttpServletRequest request) throws Exception &#123; if(file==null)&#123; MultipartHttpServletRequest rm = (MultipartHttpServletRequest) request; file=rm.getFile(&quot;pic&quot;); &#125; String realPath=request.getSession().getServletContext().getRealPath(&quot;upload&quot;); File destFile=new File(realPath+&quot;/&quot;+UUID.randomUUID().toString()+file.getName()); file.transferTo(destFile);//将上传上来的临时文件移到到我们的目标目录，File类型的也有类似的renameTo方法移动文件 return &quot;success&quot;; &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/05/31/SpringMvc的URL映射和传参案例/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA 全解]]></title>
    <url>%2F2016%2F05%2F31%2FSpringDataJPA%E5%85%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring data jpa 使用教程 常见注解1234567891011121314151617181920@Entity：表示该类对应一个数据库表实体类；@Table： 定义该实体类所对应的数据库表名，该注解非必需，只要实体类名能够与数据库表名称对应即可；@Id + @GeneratedValue：表示属性id为主键唯一标志，且是一个自增字段；@Enumerated：实体类的属性类型可以是枚举类型。该例中，通过注解@Enumerated说明bizCode属性为BizCodeEnum枚举类型。这样在存储或者查询时，可自动进行解析。在实体中虽然标注成枚举类型，但当实体持久化后，表中所对应的值仍旧是基本的数据类型。由于枚举类型有名称和值两个属性，在持久化时可以选择持久化值或者名称。EnumType.STRING表示该属性持久化类型为枚举类名称属性。同时，EnumType.ORDINAL表示持久化类型为枚举类值属性（默认）。@Column：设置属性对应的字段信息。包括字段名称、是否可空等等。@OneToMany + @JoinColumn + @ManyToOne：当表之间，存在一对多关系时可以使用；@ManyToMany + @JoinTable + @ManyToMany：多对多的情况；@OneToOne + @OneToOne：一对一外键映射关系；@Transient：瞬时字段 :不需要与数据库映射的字段，在保存的时候不需要保存倒数据库；@JsonFormat：可以方便的把Date类型直接转化为我们想要的模式，比如@JsonFormat(pattern = &quot;yyyy-MM-dd HH-mm-ss&quot;)大字段：@Lob //对应Blob字段类型 @Column(name = &quot;PHOTO&quot;) private Serializable photo; @Lob //对应Clob字段类型 @Column(name = &quot;desc&quot;) private String desc; 通过解析方法名创建查询1234567891011121314151617在上述的例子中，我们也自定义了一些查询方法，如findByBizCode，代表通过bizCode字段值来进行查询。同时还可以利用And进行多字段条件查询，如findByBusinessIdAndFollowUpId等。在查询时，通常需要同时根据多个属性进行查询，且查询的条件也格式各样（大于某个值、在某个范围等等），Spring Data JPA 为此提供了一些表达条件查询的关键字，大致如下：And --- 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；Or --- 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；Between --- 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；LessThan --- 等价于 SQL 中的 &quot;&lt;&quot;，比如 findBySalaryLessThan(int max)；GreaterThan --- 等价于 SQL 中的&quot;&gt;&quot;，比如 findBySalaryGreaterThan(int min)；IsNull --- 等价于 SQL 中的 &quot;is null&quot;，比如 findByUsernameIsNull()；IsNotNull --- 等价于 SQL 中的 &quot;is not null&quot;，比如 findByUsernameIsNotNull()；NotNull --- 与 IsNotNull 等价；Like --- 等价于 SQL 中的 &quot;like&quot;，比如 findByUsernameLike(String user)；NotLike --- 等价于 SQL 中的 &quot;not like&quot;，比如 findByUsernameNotLike(String user)；OrderBy --- 等价于 SQL 中的 &quot;order by&quot;，比如 findByUsernameOrderBySalaryAsc(String user)；Not --- 等价于 SQL 中的 &quot;！ =&quot;，比如 findByUsernameNot(String user)；In --- 等价于 SQL 中的 &quot;in&quot;，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；NotIn --- 等价于 SQL 中的 &quot;not in&quot;，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数； 自定义sql查询通过使用@Query注解，我们可以使用sql自定义查询。同时也可以实现一些复杂的查询。例子如下： /** * 使用sql语言查询符合businessType字段要求的行数 * @param businessType * @return */ @Query(&quot;SELECT count(t) FROM #{#entityName} t where t.businessType = ?1&quot;) Object queryCountByBusinessType(int businessType); #{#entityName}：使用#{#entityName}标识与实体类对应的要查询的表名； ?1：查询参数的使用。?1代表一个参数的占位符。 除此之外，还可以通过通过: 变量的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与sql中的命名参数对应，如下： @Query(&quot;SELECT count(t) FROM #{#entityName} t where t.businessType = :businessType&quot;) Object queryCountByBusinessType(@Param(&quot;businessType&quot;) int businessType); 配置扫描实体和仓库在spring boot入口类上声明就行 123456789101112@EntityScan(&quot;com.ali.crm.entity&quot;)@EnableJpaRepositories(&quot;com.ali.crm.repository&quot;)@ComponentScan(basePackages=&quot;com.ali.crm&quot;)@EnableAutoConfigurationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/05/31/SpringDataJPA全解/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统中安装Docker]]></title>
    <url>%2F2016%2F04%2F09%2FUbuntu%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[docker支持的Ubuntu版本 ubuntu Trusty 14.04 (LTS) (64 bit) ubuntu Precise 12.04 (64 bit) ubuntu Raring 13.04 and Saucy 13.10 (64 bit) 安装前检查: 内核版本 $ uname -a 检查Device Mapper (检查存储驱动文件是否存在，存在就是没有问题，不存在就不能安装docker)$ ls -l /sys/class/misc/device-mapper 安装版本的选择： 方案一：安装Ubuntu维护的docker 1. $ apt-get install docker.io //作用：安装docker 2. $ source /etc/bash_completion.d/docker.io //作用：更新配置 3. $ docker.io version //作用：查看安装的docker的版本 方案二：安装Docker公司维护的docker 推荐 1. $ whereis curl //作用：检查curl文件是否已经安装 如果提示 curl: 就说明没有安装，需要执行下面这俩命令 $ apt-get update //作用：更新软件仓库列表（比如：在windows中使用360升级软件，需要保证360软件库中软件版本列表是最新的，这个是相同的效果更新apt $ sudo apt-get install -y curl //作用:下载文件的工具（参数-y是同意的意思。没有 -y的命令也可以执行，系统会提示你是否安装，输入y，回车;加上-y参数则跳过系统提示，直接安装） 2. $ curl -sSL https://get.docker.com/ | sh //使用curl工具下载docker公司提供的快速安装脚本文件，并执行这个脚本文件，即刻快速完成安装 3. $ docker version //作用：检查安装的docker的版本 安全管理将当前用户添加到docker用户组避免每次执行docker命令都需要前面加sudo 1. $ sudo groupadd docker //作用：创建一个用户组名叫“docker” 2. $ sudo gpasswd -a 你的用户名 docker //作用：讲当前用户添加到docker用户组 3. $ sudo service docker restart //重新启动docker服务 4. 注销之后重新登录一下系统 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/04/09/Ubuntu系统中安装Docker/]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring读取配置文件的几种方式]]></title>
    <url>%2F2014%2F08%2F24%2FSpring%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring读取配置文件的几种方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.Properties;import org.junit.Test;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;/** * BeanFactory只有依赖注入功能没有AOP功能, ApplicationContext继承自BeanFactory有AOP功能 */public class GetBeanFactory &#123; /** * 加载项目内的配置文件，读取classPath之下的文件 */ public void test01() &#123; Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(resource); StudentAction studentService = (StudentAction) bf .getBean(&quot;StudentAction&quot;); System.out.println(studentService); &#125; /** * 加载项目外的配置文件,File读取C盘下的文件 */ public void test02() &#123; Resource resource = new FileSystemResource(&quot;C:/applicationContext.xml&quot;); BeanFactory beanFactory = new XmlBeanFactory(resource); StudentAction studentAction = (StudentAction) beanFactory .getBean(&quot;studentAction&quot;); System.out.println(studentAction); &#125; /** * 读取Tomcat中的application配置文件, 必须导入Spring3-Web.jar包 */ public void test03() &#123; /* * 将下面的代码必须放到jsp页面里面执行 &lt;% org.springframework.core.io.Resource * resource=null; org.springframework.beans.factory.BeanFactory * beanFactory=null; resource=new * org.springframework.web.context.support * .ServletContextResource(application * ,&quot;/WEB-INF/classes/applicationContext.xml&quot;); beanFactory=new * org.springframework.beans.factory.xml.XmlBeanFactory(resource); * System.out.println(beanFactory); %&gt; */ &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test04() &#123; ApplicationContext context = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); StudentService studentService = (StudentService) context .getBean(&quot;studentService&quot;); studentService.save(new Student(&quot;test&quot;, 22)); &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test05() &#123; ApplicationContext context = new FileSystemXmlApplicationContext( &quot;C:/applicationContext.xml&quot;); System.out.println(context.getBeanDefinitionCount());// 定义bean的总数 &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test06() &#123; String[] filepath = &#123; &quot;applicationContext.xml&quot; &#125;; ApplicationContext factory = new ClassPathXmlApplicationContext( filepath); StudentService studentService = (StudentService) factory .getBean(&quot;studentService&quot;); &#125; /** * 用Spring读取properties文件 */ @Test public void test07() throws Exception, Exception &#123; Resource r = new ClassPathResource(&quot;ssh.properties&quot;); Properties p=new Properties(); p.load(new FileInputStream(r.getFile())); System.out.println(p.get(&quot;studentDao&quot;)); &#125; @Test public void test08() throws Exception, Exception &#123; Resource r = new ClassPathResource(&quot;a.txt&quot;); &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2014/08/24/Spring读取配置文件的几种方式/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse常用快捷键]]></title>
    <url>%2F2013%2F12%2F17%2Feclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[掌握Eclipse快捷键可以帮助你快速进行程序的开发， MyEclipse是Eclipse的一个插件，Eclipse的快捷键MyEclipse同样适用。 编辑类Ctrl+N 新建文件 Ctrl+A 全选 双击括号右边（小括号，中括号，花括号）将选择括号内的所有内容 Ctrl+X 剪切 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+Z 撤销 Ctrl+Y 后悔撤销 Ctrl+D 删除当前行 Ctrl+S 保存 Ctrl+Shift+S 保存所有未保存的文件。 Alt+↑ 当前行向上移动 Alt+↓ 当前行向下移动 Ctrl+Alt+↑或↓ 快速复写当前行 Shift+Enter 在当前行的下面添加一个空行，使用时光标可以当前行的任意位置 Shift+Ctrl+Enter 在当前行的上面添加一个空行，使用时光标可以当前行的任意位置 Ctrl+Shift+X 把当前选中的文本全部变为大写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Alt+Shift+A 多行同时输入（吊炸天的功能，泡妞必备） 光标跳转Alt + → 跳到前一次编辑的地方 Alt + ← 跳到后一次编辑的地方 Ctrl+Q 跳到最后一次编辑的地方 Ctrl+L 跳转到某行（使用前最好先打开编辑器显示行号的功能【Ctrl+F10 再点击N】） Ctrl+Home 跳转到文档最前面 Ctrl+End 跳转到文档最后面 Ctrl+鼠标点击 跳到声明或定义的地方。 Ctrl+Shift+P 光标跳到匹配的括号 下面这几个一般用于搜索而且都支持通配符Ctrl+Shift+K 搜索上一个匹配的变量 Ctrl+K 搜索下一个匹配的变量 Ctrl+H 综合搜索 Ctrl+shift+T 搜索类 Ctrl+Shift+H 在层次结构中打开某个类 Ctrl+F 当前类中搜索字符 Ctrl+Shift+R 查找当前项目中的文件(比如gif文件xml文件，支持通配符) Ctrl+O 当前类的所有方法 Ctrl+T 当前类的继承结构 F4 打开类型层次结构（当前类的所有方法，以及继承结构） Ctrl+Alt+H 查看都有谁调用过当前方法(或者在方法名字上右键选择Reference再选择Project) Ctrl+E 已经在编辑窗口打开的文件列表 Ctrl+Shift+G 在workspace中搜索引用（搜狗输入法默认会占用这个键） 自动化Alt+/ 代码助手，提示代码（如果你记不住关键字一定要记住这个快捷键） Ctrl+Shift+O 自动引入所需要得包,多余的包会被删除。 Ctrl+Shift+F 自动格式化代码 Ctrl+/ 注释当前行,再按则取消注释 Ctrl+Shift+/ 注释选定的代码 Ctrl+Shift+\ 取消选定的已经注释的代码 Ctrl+/(小键盘) 折叠/展开当前类中的所有代码 Ctrl+1 快速纠正错误 修改属性Alt+Enter 显示当前选择项目或者文件的属性（我一般用来修改当前项目或文件的字符编码，或者web项目的项目名） 控制视图和编辑器Shift+Alt+b 打开源码视图上方的导航条 Ctrl+W 关闭当前Editer Ctrl+M 最大化当前的edit或View，再按则反之 Alt+- 系统菜单(最小化最大化.关闭其他,关闭当前,关闭全部) Ctrl+Shift+F4 关闭所有打开的Editer F12 全局激活编辑器 Ctrl+↑ 文本编辑器 上滚行 Ctrl+↓ 文本编辑器 下滚行 Ctrl+W 关闭当前编辑的类 Ctrl+Shift+W 关闭所有打开的类 Ctrl+Shift+F6 全局 上一个编辑器 Ctrl+F6 全局 下一个编辑器 Ctrl+F7 全局 下一个视图 Ctrl+Shift+F7 全局 上一个视图 Ctrl+F8 全局 下一个透视图 Ctrl+Shift+F8 全局 上一个透视图 重构Shift+Alt+S Source Shift+Alt+M 抽取方法 Shift+Alt+V 移动函数和变量 Shift+Alt+Z 撤销重构 F2 修改文件名项目名 Shift+Alt+R 重名命（如果你的变量被多处调用，那么修改时使用这个可以一次搞定） Shift+Alt+C 修改函数结构(有N个函数调用了这个方法,修改一次搞定) Shift+Alt+L 抽取本地变量 Shift+Alt+I 合并变量 调试F5单步调试进入函数内部。 F6单步调试不进入函数内部。 F7由函数内部返回到调用处。 F8一直执行到下一个断点。 打开文件 shift+alt+w 可以选择打开的方式，比如在资源管理器里面打开 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2013/12/17/eclipse常用快捷键/]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK环境配置]]></title>
    <url>%2F2012%2F08%2F23%2FJDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JDK环境配置 , 备忘 打开配置环境变量界面如下操作：我的电脑—属性—高级—环境变量 系统变量（S）中配置如下：新建系统变量： 变量名：JAVA_HOME 变量值：C:\Program Files\Java\jdk1.5.0_17（该目录为JDK安装的目录） 编辑CLASSPATH，如果没有该变量则新建， 变量名：CLASSPATH 变量值：%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（注：该变量值置于CLASSPATH即可， 其中：变量值最后要记得加“；”） 编辑PATH，如果没有则新建 变量名：PATH 变量值：.;%JAVA_HOME%\bin; （注：该变量值置于PATH前面，如果你只有一个JDK版本，可以不用编辑PATH，如果为了区别版本，那还是配置PATH变量值）。 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2012/08/23/JDK环境配置/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
