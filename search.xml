<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Windows使用shadowsocks和Proxifier实现为电脑上任何一个程序代理]]></title>
      <url>%2F2016%2F08%2F29%2FWindows%E4%BD%BF%E7%94%A8shadowsocks%E5%92%8CProxifier%E5%AE%9E%E7%8E%B0%E4%B8%BA%E7%94%B5%E8%84%91%E4%B8%8A%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%90%86%2F</url>
      <content type="text"><![CDATA[shadowsocks的增强工具，翻墙你需要他 1、查看我们的shadowsocks的端口 2、配置proxifier 3、检查是否可用 5、给我们的代理起个名字 然后一路点“确定“ ，遇到下面这个图，直接点”是“即可 6、测试一下 可以发现当我们使用其他的软件访问网络的时候都被代理了到目前为止我们的代理是对全局起作用的，电脑上任何一个应用程序要联网都会经过这个代理，下面我们来看如何为指定的某个程序代理 7、设置代理规则菜单：配置文件——&gt;代理规则我们来看一下最终的配置以及所代表的含义 8、另外一种临时生效代理规则通过对想代理的软件点击右键选择想使用的代理即可 9、你有可能遇到的问题在第7步的时候，你通过代理规则里面的浏览按钮选择想要代理的软件可能不一定会生效，这时你可以通过“任务管理器”找到该应用程序的进程名字，然后手动添加到代理规则的应用程序里面，多个应该程序之间使用英文分号分隔，如下图 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/08/29/Windows使用shadowsocks和Proxifier实现为电脑上任何一个程序代理/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用docker搭建FireKylin博客系统]]></title>
      <url>%2F2016%2F08%2F11%2F%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAFireKylin%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[简介：FireKylin是一个nodejs的博客系统 1.运行一个空的Ubuntu容器1234 docker run -it -p 80:8360 --name=web_node_firekylin ubuntu bash``` 2.安装nodejs 和 npm 先更新一下软件仓库列表 apt-get update 安装nodejs和npm apt-get install -y nodejs apt-get install -y npm 验证安装是否成功： 查看安装的nodejs版本 nodejs -v 查看安装的npm版本 npm -v 12345 为了兼容以前的老版本建议安装这个 apt-get install nodejs-legacy4.下载网站源码文件 创建一个目录作为我们的站点目录 cd home &amp;&amp; mkdir myblog &amp;&amp; cd myblog 安装wget用于下载文件 apt-get install -y wget wget -c http://firekylin.org/release/firekylin_0.12.6.tar.gz 把文件解压 tar -zxvf firekylin_0.12.6.tar.gz 进入解压后的文件夹,安装node依赖 cd /home/myblog/firekylin &amp;&amp; npm install 127.服务器环境推荐pm2启动 安装vim用于修改配置文件 apt-get install -y vim-gtk 安装pm2 npm install -g pm2 将pm2_default.json配置文件的名称修改为pm2.json mv pm2_default.json pm2.json 修改pm2.json配置，将cwd修改为当前目录 12 ![alt](http://www.tfgzs.net/static/upload/201608/1890E7I2lJH5kMSEulLHqxGr.png) 8.因为我们的网站运行在docker容器里面需要端口映射，而firekylin默认不让通过ip:端口号的形式访问，所以这里需要解除限制，参考：https://thinkjs.org/zh-cn/doc/2.1/force_proxy.html 在配置文件 src/common/config/hook.js，添加如下的配置： export default { request_begin: [&quot;prepend&quot;, &quot;force_proxy&quot;] } 修改配置 src/common/config/config.js 中的host为0.0.0.0 export default { host: &quot;0.0.0.0&quot; } 19，启动项目 pm2 start pm2.json ``` docker容器内部访问 http://127.0.0.1:8360宿主机里面访问 http://127.0.0.1:80 首次打开会进入安装界面，按照提示填写数据库信息和网站管理员信息就行了 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/08/11/使用docker搭建FireKylin博客系统/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMvc的URL映射和传参案例]]></title>
      <url>%2F2016%2F05%2F31%2FSpringMvc%E7%9A%84URL%E6%98%A0%E5%B0%84%E5%92%8C%E4%BC%A0%E5%8F%82%E6%A1%88%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[Springmvc的基本使用，包括url映射、参数映射、页面跳转、ajax和文件上传 以前学习的时候写的代码案例，今天整理笔记的时候找到了,发上来当个在线笔记用吧，免的时间长了又忘了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271package sy.controller;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.Random;import java.util.UUID;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.io.IOUtils;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.ServletRequestDataBinder;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.multipart.commons.CommonsMultipartFile;import org.springframework.web.servlet.ModelAndView;import power.FuncConstants;import power.Permission;import sy.bean.TestPerson;// 用来标注此类事springMVC管理的控制层的类@Controller// 为了防止多个控制层类有相同的方法所以要为每个控制层类起个唯一的标示名@RequestMapping(value = &quot;/test&quot;)// @Scope(&quot;prototype&quot;) ,如果不加这个注释那么该controller就是单列的，一般我们不在controller当中定义成员变量所以不用加这个注释，struts2中的action中会加这个注释就是因为里面经常会定义成员变量，如果不加这个注释当有多个请求的时候就会照成数据共享错误public class TestController &#123; @RequestMapping(&quot;/hello.do&quot;) // 访问此方法的url路径/test/hello.do public String hello() &#123; return &quot;index&quot;; &#125; // ===========================获取页面中传进来的参数======================================================= /** * 方式一：通过request请求方式接收前台页面传过来的参数 */ @RequestMapping(&quot;/toPerson1.do&quot;) // 访问此方法的url路径为/test/toPerson1.do public String toPerson1(HttpServletRequest request) &#123; String name = request.getParameter(&quot;name&quot;); System.out.println(name); return &quot;index&quot;; &#125; /** * 方式二：通过相匹配的参数列表接收页面参数_String, * 而且在页面参数和参数列表中的参数类型相容的情况下是可以自动类型转换的_Integer * 时间类型如果传入的时间格式比较特殊可以通过自定义专门的转换器来解决（属性编辑器） */ @RequestMapping(&quot;/toPerson2.do&quot;) // 访问此方法的url路径为/test/toPerson2.do public String toPerson2(String name, Integer age, Date birthday) &#123; System.out.println(&quot;姓名：&quot; + name + &quot;,年龄：&quot; + age + &quot;,生日&quot; + birthday); return &quot;index&quot;; &#125; /** * 方式2.1 如果你页面传入的和用于接收的非要不一样那么可以用@RequestParam指定 */ @RequestMapping(&quot;/toPerson21.do&quot;) // 访问此方法的url路径为/test/toPerson21.do public String toPerson21(@RequestParam(&quot;name&quot;) String userName, Integer age, Date birthday) &#123; System.out.println(&quot;姓名：&quot; + userName + &quot;,年龄：&quot; + age + &quot;,生日&quot; + birthday); return &quot;index&quot;; &#125; /** * 注册时间类型的属性编辑器 */ @InitBinder public void initBinder(ServletRequestDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;), true)); &#125; /** * 方式三：如果页面传入的参数和接收的实体类（可以为多个实体）中set方法中的参数一致(首字母大小写可以不一致)， * 那么就可以直接给实体类的属性赋值，没有匹配上的将会被赋值为null */ @RequestMapping(&quot;/toPerson3.do&quot;) // 访问此方法的url路径为/test/toPerson3.do public String toPerson3(TestPerson p) &#123; System.out.println(p); return &quot;index&quot;; &#125; /** * 方式三：如过页面传来两个同名的参数值，方法中可以用一个同名参数数组去接收，而且接收到的参数顺序和传入时的相同。 * 如果没有定义成数组传入的参数会以逗号分隔 */ @RequestMapping(&quot;/toPerson4.do&quot;) // 访问此方法的url路径为/test/toPerson4.do public String toPerson4(String[] name) &#123; for (int i = 0; i &lt; name.length; i++) &#123; System.out.println(name[i]); &#125; return &quot;index&quot;; &#125; /** * 方式四：指定form表单的请求方式，如果不指定，那么post和get都可以访问本方法 * desc：@RequestMapping( method=RequestMethod.POST )可以指定请求方式，前台页面就必须要以它制定好的方式来访问，否则出现405错误 */ @RequestMapping(value = &quot;/toPerson5.do&quot;, method = RequestMethod.POST) public String toPerson5(TestPerson person) &#123; System.out.println(person); return &quot;index&quot;; &#125; // ===========================向页面传递参数======================================================= /** * 方式一 desc：方法的返回值采用ModelAndView， new ModelAndView(&quot;index&quot;, map); ，相当于把结果数据放到request里面 */ @RequestMapping(&quot;/toPerson6.do&quot;) public ModelAndView toPerson6() throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;p&quot;, person); return new ModelAndView(&quot;index&quot;, map); &#125; /** * 方式二 desc：直接在方法的参数列表中来定义Map，这个Map即使ModelAndView里面的Map， 由视图解析器统一处理，统一走ModelAndView的接口 */ @RequestMapping(&quot;/toPerson7.do&quot;) public String toPerson7(Map&lt;String, Object&gt; map) throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); map.put(&quot;p&quot;, person); return &quot;index&quot;; &#125; /** * 方式三 desc：在参数列表中直接定义Model，model.addAttribute(&quot;p&quot;, person);把参数值放到request类里面去，建议使用 */ @RequestMapping(&quot;/toPerson8.do&quot;) public String toPerson8(Model model) throws Exception &#123; TestPerson person = new TestPerson(); person.setName(&quot;james&quot;); person.setAge(28); person.setAddress(&quot;maami&quot;); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = format.parse(&quot;1985-04-22&quot;); person.setBirthday(date); // 把参数值放到request类里面去 model.addAttribute(&quot;p&quot;, person); return &quot;index&quot;; &#125; // ===========================Ajax的使用======================================================= /** * 方式一 ：ajax的请求返回值类型应该是void，参数列表里直接定义HttpServletResponse， 获得PrintWriter的类，最后可把结果写到页面 */ @RequestMapping(&quot;/ajax.do&quot;) public void ajax(String name, HttpServletResponse response) &#123; String result = &quot;hello &quot; + name; try &#123; response.getWriter().write(result); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 方式二 ：直接在参数的列表上定义PrintWriter，out.write(result);把结果写到页面，建议使用的 */ @RequestMapping(&quot;/ajax1.do&quot;) public void ajax1(String name, PrintWriter out) &#123; String result = &quot;hello &quot; + name; out.write(result); &#125; // ========================跳转 转发和重定向=================================== @RequestMapping(&quot;/redirectToForm.do&quot;) public String redirectToForm() &#123; //同一个类中 desc：controller内部重定向，redirect:加上同一个controller中的requestMapping的值 return &quot;redirect:upload.do&quot;; //不同的类中 desc：controller之间的重定向：必须要指定好controller的命名空间再指定requestMapping的值， redirect：后必须要加/,是从根目录开始// return &quot;redirect:/test/toForm.do&quot;; //同一个类中 desc：controller内部转发，redirect:加上同一个controller中的requestMapping的值// return &quot;forward:toForm.do&quot;; &#125; // ===========================文件上传======================== @RequestMapping(&quot;/upload.do&quot;) // 访问此方法的url路径/test/hello.do public String upload() &#123; return &quot;fileUpload&quot;; &#125; /** * 文件上传方式一 * @param request * @return * @throws Exception */ @RequestMapping(value = &quot;/fileUpload.do&quot;) public String fileUpload(HttpServletRequest request) throws Exception &#123; // 第一步转化request MultipartHttpServletRequest rm = (MultipartHttpServletRequest) request; // 获得原始文件 CommonsMultipartFile cfile = (CommonsMultipartFile) rm.getFile(&quot;pic&quot;); // 获得原始文件名 String origFileName = cfile.getOriginalFilename(); // 获得原始文件的后缀 XXX.jpg String suffix = origFileName.contains(&quot;.&quot;) ? origFileName.substring(origFileName.lastIndexOf(&quot;.&quot;)) : &quot;error&quot;; if (&quot;error&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;error&quot;; &#125; // 获得原始文件的字节数组 byte[] bfile = cfile.getBytes(); // 新文件名=当前时间的毫秒数+3位随机数 String fileName = String.valueOf(System.currentTimeMillis()); // 获得三位随机数 Random random = new Random(); for (int i = 0; i &lt; 3; i++) &#123; fileName = fileName + random.nextInt(9); &#125; // 拿到项目的部署路径 String path = request.getSession().getServletContext().getRealPath(&quot;/&quot;); // 将用户上传的文件保存到服务器上 OutputStream out = new FileOutputStream(new File(path + &quot;/upload/&quot; + fileName + suffix)); IOUtils.write(bfile, out); out.close(); return &quot;success&quot;; &#125; /** * 文件上传方式二 * @param request * @return * @throws Exception */ @RequestMapping(value = &quot;/fileUpload2.do&quot;) public String fileUpload2(@RequestParam(value=&quot;pc&quot;,required=false) MultipartFile file,HttpServletRequest request) throws Exception &#123; if(file==null)&#123; MultipartHttpServletRequest rm = (MultipartHttpServletRequest) request; file=rm.getFile(&quot;pic&quot;); &#125; String realPath=request.getSession().getServletContext().getRealPath(&quot;upload&quot;); File destFile=new File(realPath+&quot;/&quot;+UUID.randomUUID().toString()+file.getName()); file.transferTo(destFile);//将上传上来的临时文件移到到我们的目标目录，File类型的也有类似的renameTo方法移动文件 return &quot;success&quot;; &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2016/05/31/SpringMvc的URL映射和传参案例/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring读取配置文件的几种方式]]></title>
      <url>%2F2014%2F08%2F24%2FSpring%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[Spring读取配置文件的几种方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.Properties;import org.junit.Test;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;/** * BeanFactory只有依赖注入功能没有AOP功能, ApplicationContext继承自BeanFactory有AOP功能 */public class GetBeanFactory &#123; /** * 加载项目内的配置文件，读取classPath之下的文件 */ public void test01() &#123; Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(resource); StudentAction studentService = (StudentAction) bf .getBean(&quot;StudentAction&quot;); System.out.println(studentService); &#125; /** * 加载项目外的配置文件,File读取C盘下的文件 */ public void test02() &#123; Resource resource = new FileSystemResource(&quot;C:/applicationContext.xml&quot;); BeanFactory beanFactory = new XmlBeanFactory(resource); StudentAction studentAction = (StudentAction) beanFactory .getBean(&quot;studentAction&quot;); System.out.println(studentAction); &#125; /** * 读取Tomcat中的application配置文件, 必须导入Spring3-Web.jar包 */ public void test03() &#123; /* * 将下面的代码必须放到jsp页面里面执行 &lt;% org.springframework.core.io.Resource * resource=null; org.springframework.beans.factory.BeanFactory * beanFactory=null; resource=new * org.springframework.web.context.support * .ServletContextResource(application * ,&quot;/WEB-INF/classes/applicationContext.xml&quot;); beanFactory=new * org.springframework.beans.factory.xml.XmlBeanFactory(resource); * System.out.println(beanFactory); %&gt; */ &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test04() &#123; ApplicationContext context = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); StudentService studentService = (StudentService) context .getBean(&quot;studentService&quot;); studentService.save(new Student(&quot;test&quot;, 22)); &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test05() &#123; ApplicationContext context = new FileSystemXmlApplicationContext( &quot;C:/applicationContext.xml&quot;); System.out.println(context.getBeanDefinitionCount());// 定义bean的总数 &#125; /** * ApplicationContext继承自BeanFactory有AOP功能 */ public void test06() &#123; String[] filepath = &#123; &quot;applicationContext.xml&quot; &#125;; ApplicationContext factory = new ClassPathXmlApplicationContext( filepath); StudentService studentService = (StudentService) factory .getBean(&quot;studentService&quot;); &#125; /** * 用Spring读取properties文件 */ @Test public void test07() throws Exception, Exception &#123; Resource r = new ClassPathResource(&quot;ssh.properties&quot;); Properties p=new Properties(); p.load(new FileInputStream(r.getFile())); System.out.println(p.get(&quot;studentDao&quot;)); &#125; @Test public void test08() throws Exception, Exception &#123; Resource r = new ClassPathResource(&quot;a.txt&quot;); &#125;&#125; 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2014/08/24/Spring读取配置文件的几种方式/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse常用快捷键]]></title>
      <url>%2F2013%2F12%2F17%2Feclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[掌握Eclipse快捷键可以帮助你快速进行程序的开发， MyEclipse是Eclipse的一个插件，Eclipse的快捷键MyEclipse同样适用。 一.编辑类Ctrl+N 新建文件 Ctrl+A 全选 双击括号右边（小括号，中括号，花括号）将选择括号内的所有内容 Ctrl+X 剪切 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+Z 撤销 Ctrl+Y 后悔撤销 Ctrl+D 删除当前行 Ctrl+S 保存 Ctrl+Shift+S 保存所有未保存的文件。 Alt+↑ 当前行向上移动 Alt+↓ 当前行向下移动 Ctrl+Alt+↑或↓ 快速复写当前行 Shift+Enter 在当前行的下面添加一个空行，使用时光标可以当前行的任意位置 Shift+Ctrl+Enter 在当前行的上面添加一个空行，使用时光标可以当前行的任意位置 Ctrl+Shift+X 把当前选中的文本全部变为大写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Alt+Shift+A 多行同时输入（吊炸天的功能，泡妞必备） 二、光标跳转Alt + → 跳到前一次编辑的地方 Alt + ← 跳到后一次编辑的地方 Ctrl+Q 跳到最后一次编辑的地方 Ctrl+L 跳转到某行（使用前最好先打开编辑器显示行号的功能【Ctrl+F10 再点击N】） Ctrl+Home 跳转到文档最前面 Ctrl+End 跳转到文档最后面 Ctrl+鼠标点击 跳到声明或定义的地方。 Ctrl+Shift+P 光标跳到匹配的括号 三、下面这几个一般用于搜索而且都支持通配符Ctrl+Shift+K 搜索上一个匹配的变量 Ctrl+K 搜索下一个匹配的变量 Ctrl+H 综合搜索 Ctrl+shift+T 搜索类 Ctrl+Shift+H 在层次结构中打开某个类 Ctrl+F 当前类中搜索字符 Ctrl+Shift+R 查找当前项目中的文件(比如gif文件xml文件，支持通配符) Ctrl+O 当前类的所有方法 Ctrl+T 当前类的继承结构 F4 打开类型层次结构（当前类的所有方法，以及继承结构） Ctrl+Alt+H 查看都有谁调用过当前方法(或者在方法名字上右键选择Reference再选择Project) Ctrl+E 已经在编辑窗口打开的文件列表 Ctrl+Shift+G 在workspace中搜索引用（搜狗输入法默认会占用这个键） 四、自动化Alt+/ 代码助手，提示代码（如果你记不住关键字一定要记住这个快捷键） Ctrl+Shift+O 自动引入所需要得包,多余的包会被删除。 Ctrl+Shift+F 自动格式化代码 Ctrl+/ 注释当前行,再按则取消注释 Ctrl+Shift+/ 注释选定的代码 Ctrl+Shift+\ 取消选定的已经注释的代码 Ctrl+/(小键盘) 折叠/展开当前类中的所有代码 Ctrl+1 快速纠正错误 五、修改属性Alt+Enter 显示当前选择项目或者文件的属性（我一般用来修改当前项目或文件的字符编码，或者web项目的项目名） 六、控制视图和编辑器Shift+Alt+b 打开源码视图上方的导航条 Ctrl+W 关闭当前Editer Ctrl+M 最大化当前的edit或View，再按则反之 Alt+- 系统菜单(最小化最大化.关闭其他,关闭当前,关闭全部) Ctrl+Shift+F4 关闭所有打开的Editer F12 全局激活编辑器 Ctrl+↑ 文本编辑器 上滚行 Ctrl+↓ 文本编辑器 下滚行 Ctrl+W 关闭当前编辑的类 Ctrl+Shift+W 关闭所有打开的类 Ctrl+Shift+F6 全局 上一个编辑器 Ctrl+F6 全局 下一个编辑器 Ctrl+F7 全局 下一个视图 Ctrl+Shift+F7 全局 上一个视图 Ctrl+F8 全局 下一个透视图 Ctrl+Shift+F8 全局 上一个透视图 七、重构Shift+Alt+S Source Shift+Alt+M 抽取方法 Shift+Alt+V 移动函数和变量 Shift+Alt+Z 撤销重构 F2 修改文件名项目名 Shift+Alt+R 重名命（如果你的变量被多处调用，那么修改时使用这个可以一次搞定） Shift+Alt+C 修改函数结构(有N个函数调用了这个方法,修改一次搞定) Shift+Alt+L 抽取本地变量 Shift+Alt+I 合并变量 八、调试F5单步调试进入函数内部。 F6单步调试不进入函数内部。 F7由函数内部返回到调用处。 F8一直执行到下一个断点。 九、打开文件 shift+alt+w 可以选择打开的方式，比如在资源管理器里面打开 本文出自 “腾飞工作室” 博客，请务必保留此出处：http://tfgzs.net/2013/12/17/eclipse常用快捷键/]]></content>
    </entry>

    
  
  
</search>
